// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMainNoTransparent
#pragma kernel CSMainOnlyTransparent

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<int4> DataIn;



struct DrawingData {
	int4 data1;
	int4 data2;
};

AppendStructuredBuffer<DrawingData> DrawingThings;


#define CHUNK_SIZE 16

int T3(uint3 id)
{
	return id.x + id.y * CHUNK_SIZE + id.z * CHUNK_SIZE*CHUNK_SIZE;
}


[numthreads(8,8,8)]
void CSMainNoTransparent(uint3 id : SV_DispatchThreadID)
{
	int4 blockVals = DataIn[T3(id)];
	int blockVal = blockVals.x;
	// 0 is air

	int3 ids = id;
	bool edge = ids.x == 0 || ids.y == 0 || ids.z == 0 || ids.x == CHUNK_SIZE - 1 || ids.y == CHUNK_SIZE - 1 || ids.z == CHUNK_SIZE - 1;

	bool hasAirNeighbors =
		DataIn[T3(ids + int3(0, 0, 1))] <= 0 || DataIn[T3(ids + int3(0, 0, -1))] <= 0 ||
		DataIn[T3(ids + int3(0, 1, 0))] <= 0 || DataIn[T3(ids + int3(0, -1, 0))] <= 0 ||
		DataIn[T3(ids + int3(1, 0, 0))] <= 0 || DataIn[T3(ids + int3(-1, 0, 0))] <= 0;

	if (blockVal > 0 && (edge || hasAirNeighbors))
	{
		DrawingData res;
		res.data1 = int4(id.x, id.y, id.z, blockVal);
		res.data2 = blockVals;
		DrawingThings.Append(res);
	}
}

[numthreads(8, 8, 8)]
void CSMainOnlyTransparent(uint3 id : SV_DispatchThreadID)
{
	int4 blockVals = DataIn[T3(id)];
	int blockVal = blockVals.x;
	// 0 is air

	int3 ids = id;
	bool edge = ids.x == 0 || ids.y == 0 || ids.z == 0 || ids.x == CHUNK_SIZE - 1 || ids.y == CHUNK_SIZE - 1 || ids.z == CHUNK_SIZE - 1;

	bool hasAirNeighbors =
		DataIn[T3(ids + int3(0, 0, 1))] <= 0 || DataIn[T3(ids + int3(0, 0, -1))] <= 0 ||
		DataIn[T3(ids + int3(0, 1, 0))] <= 0 || DataIn[T3(ids + int3(0, -1, 0))] <= 0 ||
		DataIn[T3(ids + int3(1, 0, 0))] <= 0 || DataIn[T3(ids + int3(-1, 0, 0))] <= 0;

	if (blockVal < 0 && (edge || hasAirNeighbors))
	{
		DrawingData res;
		res.data1 = int4(id.x, id.y, id.z, blockVal);
		res.data2 = blockVals;
		DrawingThings.Append(res);
	}
}
